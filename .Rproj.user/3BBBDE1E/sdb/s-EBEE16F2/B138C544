{
    "contents" : "############ Phylogenetic Diversity Faith (adapted from pd function in picante library) #######################\npdnew <- function (samp, tree, include.root = TRUE) {\n  if (is.null(tree$edge.length)) {\n    stop(\"Tree has no branch lengths, cannot compute pd\")\n  }\n  species <- colnames(samp)\n  tree  <- node.age(tree)\n  PDout <- apply(samp,1, function(x) {\n    present <- species[x > 0]\n    treeabsent <- tree$tip.label[which(!(tree$tip.label %in%present))]\n    if (length(present) == 0) {\n      PD <- 0\n    }\n    else if (length(present) == 1) {\n      if (!is.rooted(tree) || !include.root) {\n        warning(\"Rooted tree and include.root=TRUE argument required to calculate PD of single-species sampunities. Single species sampunity assigned PD value of NA.\")\n        PD <- NA\n      }\n      else {\n        PD <- tree$ages[which(tree$edge[, 2] ==\n                                which(tree$tip.label == present))]\n      }\n    }\n    else if (length(treeabsent) == 0) {\n      PD <- sum(tree$edge.length)\n    }\n    else {\n      sub.tree <- drop.tip(tree, treeabsent)\n      if (include.root) {\n        if (!is.rooted(tree)) {\n          stop(\"Rooted tree required to calculate PD with include.root=TRUE argument\")\n        }\n        sub.tree <- node.age(sub.tree)\n        sub.tree.depth <- max(sub.tree$ages)\n        orig.tree.depth <- max(tree$ages[which(tree$edge[,2] %in% which(tree$tip.label %in% present))])\n        PD <- sum(sub.tree$edge.length) + (orig.tree.depth - sub.tree.depth)\n      }\n      else {\n        PD <- sum(sub.tree$edge.length)\n      }\n    }\n    SR <- length(present)\n    PDout <- c(PD,SR)\n  } )\n  PDout <- t(PDout)\n  rownames(PDout) <- rownames(samp)\n  colnames(PDout) <- c(\"PD\",\"SR\")\n  return(PDout)\n} # end of function pdnew\n\n\n\n\n\n\n############ Paired matrix to distance matrix conversion (utility function) #######################\n\ndist.mat <- function(com,pair) {\n  \n  ncom <- nrow(com)\n  distmat <- matrix(nrow=ncom,ncol=ncom,0,dimnames=list(rownames(com),rownames(com)))\n  st <- c(0,cumsum(seq(ncom-1,2)))+1\n  end <- cumsum(seq(ncom-1,1))\n  for (i in 1:(ncom-1)) distmat[i,(ncom:(seq(1,ncom)[i]))]=c(pair[end[i]:st[i]],0)\n  distmat <- as.dist(t(distmat))\n  return(distmat)\n  \n} # end of function dist.mat\n\n\nphylo.betapart.core<-function(x, tree)\n{\n\n    if (!is.matrix(x)) {\n        x <- as.matrix(x)\n    }\n\n    if(nrow(x)<2)\n        stop(\"Computing dissimilairty requires at least 2 communities\", call. = TRUE)\n\n    if (!is.numeric(x))\n        stop(\"The data in 'x' is not numeric.\", call. = TRUE)\n\n    xvals <- unique(as.vector(x))\n    if (any(!is.element(xvals, c(0, 1))))\n        stop(\"The community matrix contains values other than 0 and 1: data should be presence/absence.\", call. = TRUE)\n\n    if (class(tree)!=\"phylo\")\n        stop(\"### invalid tree's format: \\\"phylo\\\" format required ###\\n\\n\", call. = TRUE)\n\n    if(any(!(colnames(x)%in%tree$tip)))\n        warning(\"At least one species in community matrix is not included in the tree\" , call. = TRUE)\n\n\n    # pariwise comparisons\n    com=x\n    combin  <-  combn(nrow(com),2) # table with all pairs\n    labcomb <-  data.table(x=combin[1,], y=combin[2,])[, .(x = sprintf(\"%s-%s\",x,y))]$x # SPEEDUP #1\n    # ORIGINAL LINE .. SLOWER ..labcomb <-  apply(combin,2,function(x) paste(rownames(com)[x],collapse=\"-\"))\n    print('computing PD for each community of the community matrix')\n    pd <-  pdnew(com,tree)[,\"PD\"] # PD for each community of the community matrix\n#     com.tot.pair.old <- t(apply(combin,2,function(x) { # SPEEDUP 2\n#       colSums(com[x,])>0\n#     }))\n    \n    #     com.tot.pair <- t(apply(combin,2,function(x) { # much much faster than colsums\n    #       com[x[1],] + com[x[2],] > 0\n    #     }))\n    #     pd.tot.pair <- pdnew(com.tot.pair,tree)[,\"PD\"]\n    chunkSize <- 100\n    chunksCnt <- ceiling(ncol(combin)/chunkSize)\n    print('computing PD of the two communities combined')\n    \n    if(Sys.info()['sysname'] == 'Linux') {\n      canRunInParallel = TRUE\n    } else {\n      canRunInParallel = FALSE\n    }\n    \n    if(canRunInParallel) {\n      cores <- detectCores(all.tests=TRUE, logical=FALSE)\n      cl <- makeForkCluster(cores)\n      registerDoParallel(cl)  \n      logFile <- tempfile()\n      print(sprintf('using log file %s for debug messages in parallel cycle', logFile))\n    }\n    \n    pd.tot.pair <- unlist(llply(1:chunksCnt, function(x) {   # PD of the two communities combined\n      chunkId <- x - 1\n      if(canRunInParallel) {\n        sink(file = logFile, append = TRUE)\n        print(sprintf('running %d/%d', chunkId, chunksCnt))\n        sink()\n      }\n      start <- chunkId * chunkSize + 1\n      end <- min(start + chunkSize - 1, ncol(combin))\n      chunk <- combin[,start:end]\n      com.tot.pair <- t(apply(chunk,2,function(x) { # much much faster than colsums\n        com[x[1],] + com[x[2],] > 0\n      }))\n      pdnew(com.tot.pair,tree)[,\"PD\"]\n    }, .progress=\"time\", .parallel = canRunInParallel))\n    if(canRunInParallel) {\n      stopCluster(cl)\n    }\n    print('computing sum of PD for each community, separetely')\n    sum.pd.pair <- apply(combin,2,function(x) sum(pd[x])) # Sum of PD for each community, separetely\n    com.tot.multi <- t(as.matrix(colSums(com)>0))\n    print('computing PD of all communities combined')\n    pd.tot.multi <- as.numeric(pdnew(com.tot.multi,tree)[,\"PD\"])  # PD of all communities combined\n\n    min.not.shared <- apply(pd.tot.pair-t(combn(pd,2)),1,min) # minimun (b,c)\n    max.not.shared <- apply(pd.tot.pair-t(combn(pd,2)),1,max) # maximum (b,c)\n    sum.not.shared <- 2*pd.tot.pair - sum.pd.pair  # b+c\n    shared <- pd.tot.pair - sum.not.shared    # a\n\n    # returning results of functional.betapart.core\n    phylo.computations<-list( sumSi=sum(pd),St=pd.tot.multi, shared = dist.mat(com,shared), sum.not.shared = dist.mat(com,sum.not.shared),\n    \t\t\t\t\t\t\t\tmax.not.shared = dist.mat(com,max.not.shared), min.not.shared = dist.mat(com,min.not.shared))\n\tclass(phylo.computations) <- \"phylo.betapart\"\n    return(phylo.computations)\n\n} # end of function",
    "created" : 1437085111246.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3475459392",
    "id" : "B138C544",
    "lastKnownWriteTime" : 1437094022,
    "path" : "~/Desktop/optimizeit/betapart/R/phylo.betapart.core.r",
    "project_path" : "betapart/R/phylo.betapart.core.r",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "type" : "r_source"
}